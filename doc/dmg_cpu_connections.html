<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DMG-CPU SM83 Core Connections</title>
<link rel="icon" href="/gameboy.svg">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Description of all internal input and output connections from/to the SM83 CPU core inside the DMG-CPU B Game Boy chip.">
<style>
 img {
  max-width: 100%;
  display:   inline;
 }
 table.default {
  border-top:    1px solid #b2b2b2;
  border-left:   1px solid #b2b2b2;
  border-bottom: 1px solid #4c4c4c;
  border-right:  1px solid #4c4c4c;
 }
 table.default tr th {
   border-top:    1px solid #4c4c4c;
   border-left:   1px solid #4c4c4c;
   border-bottom: 1px solid #b2b2b2;
   border-right:  1px solid #b2b2b2;
 }
 table.default tr td {
   border-top:    1px solid #4c4c4c;
   border-left:   1px solid #4c4c4c;
   border-bottom: 1px solid #b2b2b2;
   border-right:  1px solid #b2b2b2;
 }
</style>
</head>
<body>
<nav><p><a href="http://iceboy.a-singer.de/">Home</a></p>
<hr></nav>
<main><h1>DMG-CPU SM83 Core Connections</h1>
<p>This is a list of all connections to/from the SM83 CPU core as seen in the
<a href="https://siliconpr0n.org/map/nintendo/dmg-cpu-b/">Gameboy DMG-CPU-B die shot</a>.
The wire and cell names are taken from our
<a href="https://github.com/msinger/dmg-schematics">schematics of the DMG-CPU B</a>.</p>
<p>For a deeper understanding of the CPU, you should have a look at the reverse engineering efforts of
<a href="https://github.com/emu-russia/dmgcpu">ogamespec</a> and
<a href="https://github.com/Gekkio/gb-research/tree/main/sm83-cpu-core">Gekkio</a>. Or you can play
with the <a href="https://iceboy.a-singer.de/visual6502/expert-sm83.html">visual6502 port</a> of the CPU.</p>
<p>Please report any errors I made <a href="https://github.com/msinger/gbreveng/issues">here</a>.</p>
<h2>SM83 "Pinout"</h2>
<p><img src="img/cells/cpu_desc.png?v=0" alt="SM83 CPU core inside Game Boy DMG-CPU B chip"></p>
<h2>SM83 Connections</h2>
<table class="default"><tr>
<th colspan="2">I/O</th>
<th>Port Name</th>
<th>Wire Name</th>
<th>Description</th>
</tr><tr>
<td>T1</td>
<td>O</td>
<td>M1</td>
<td><a href="/sm83_map/?wires=0&view=w:ctl_fetch">CTL_FETCH</a></td>
<td>Machine cycle one (M1) synchronization signal. High during the instruction fetch cycle (M1).<br>
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
M1:           __|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>T2</td>
<td>I</td>
<td><span style="text-decoration:overline">EXEC_PHASE</span></td>
<td><a href="/sm83_map/?wires=0&view=w:~%7bexec_phase%7d"><span style="text-decoration:overline">EXEC_PHASE</span></a></td>
<td>A gated 1 MiHz clock, which goes low the moment the CPU outputs the new address at the beginning of a
memory cycle. It is low while the address is valid on the cartridge port and high during the short time when the
address high byte on the cartridge port is usually zeroed.<br>
The rising edge of this clock updates the <a href="/sm83_map/?wires=0&view=c:zivv">DFF</a> that stores the effective
IME (Interrupt Master Enable) flag.<br>
The CPU can stop this clock by driving <span style="text-decoration:overline">HALT</span> (T11) low, in which case it
stays permanently high. This is the inverse of EXEC_PHASE (T3).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
<span style="text-decoration:overline">EXEC_PHASE</span>:   ‾‾|____________________|
</pre></td>
</tr><tr>
<td>T3</td>
<td>I</td>
<td>EXEC_PHASE</td>
<td><a href="/sm83_map/?wires=0&view=w:exec_phase">EXEC_PHASE</a></td>
<td>A gated 1 MiHz clock, which goes high the moment the CPU outputs the new address at the beginning of a
memory cycle. It is high while the address is valid on the cartridge port and low during the short time when the
address high byte on the cartridge port is usually zeroed.<br>
Most control signals generated from the dynamic NMOS decoders are valid while this clock is high, and are precharged
while it is low. This clock is also responsible for precharging other components while it is low: Internal and external
data bus, dynamic NMOS logic of ALU, ALU operand buses, and the input bus of the increment/decrement unit (IDU).<br>
The CPU can stop this clock by driving <span style="text-decoration:overline">HALT</span> (T11) low, in which case it
stays permanently low. This is the inverse of <span style="text-decoration:overline">EXEC_PHASE</span> (T2).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
EXEC_PHASE:   __|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>T4</td>
<td>I</td>
<td><span style="text-decoration:overline">DATA_PHASE</span></td>
<td><a href="/sm83_map/?wires=0&view=w:~%7bdata_phase%7d"><span style="text-decoration:overline">DATA_PHASE</span></a></td>
<td>A gated 1 MiHz clock, which is identical to the 1 MiHz PHI clock signal on the cartridge port.<br>
While this clock is high, IRQ_LATCH[0..7] are enabled.<br>
The CPU can stop this clock by driving <span style="text-decoration:overline">HALT</span> (T11) low, in which case it
stays permanently high. This is the inverse of DATA_PHASE (T5).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
<span style="text-decoration:overline">DATA_PHASE</span>:   ‾‾‾‾‾‾‾‾‾‾‾|___________|
</pre></td>
</tr><tr>
<td>T5</td>
<td>I</td>
<td>DATA_PHASE</td>
<td><a href="/sm83_map/?wires=0&view=w:data_phase">DATA_PHASE</a></td>
<td>A gated 1 MiHz clock, which is the inverse of the 1 MiHz PHI clock signal on the cartridge port.<br>
The few control signals generated by the dynamic NMOS decoders that are not timed by EXEC_PHASE (T3), are valid while
DATA_PHASE is high. Those signals are write enable control signals for registers and flags. It makes sense that those
are only asserted during the data phase where the value on the data bus is valid. While DATA_PHASE is low, those
signals are precharged. DATA_PHASE also precharges the following: Dynamic NMOS logic that drives new values for writing
registers, NMOS chains in increment/decrement unit (IDU). It also controls some latches in the interrupt logic part
of the sequencer, and it gives shape to the RD (R1) signal.<br>
The CPU can stop this clock by driving <span style="text-decoration:overline">HALT</span> (T11) low, in which case it
stays permanently low. This is the inverse of <span style="text-decoration:overline">DATA_PHASE</span> (T4).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
DATA_PHASE:   ___________|‾‾‾‾‾‾‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>T6</td>
<td>I</td>
<td><span style="text-decoration:overline">WRITE_PHASE</span></td>
<td><a href="/sm83_map/?wires=0&view=w:~%7bwrite_phase%7d"><span style="text-decoration:overline">WRITE_PHASE</span></a></td>
<td>A gated 1 MiHz clock, which is low during the fourth quarter of each memory cycle.<br>
The CPU can stop this clock by driving <span style="text-decoration:overline">HALT</span> (T11) low, in which case it
stays permanently high. This is the inverse of WRITE_PHASE (T7).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
<span style="text-decoration:overline">WRITE_PHASE</span>:  ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|_____|
</pre></td>
</tr><tr>
<td>T7</td>
<td>I</td>
<td>WRITE_PHASE</td>
<td><a href="/sm83_map/?wires=0&view=w:write_phase">WRITE_PHASE</a></td>
<td>A gated 1 MiHz clock, which is high during the fourth quarter of each memory cycle.<br>
Registers and flags are written during the high phase of this clock when their respective write enable signals are
also asserted. When this clock is low, some dynamic NMOS logic responsible for interrupt priority decoding is
precharged.<br>
The CPU can stop this clock by driving <span style="text-decoration:overline">HALT</span> (T11) low, in which case it
stays permanently low. This is the inverse of <span style="text-decoration:overline">WRITE_PHASE</span> (T6).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
WRITE_PHASE:  _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>T8</td>
<td>I</td>
<td><span style="text-decoration:overline">PCH_PHASE</span></td>
<td><a href="/sm83_map/?wires=0&view=w:~%7bpch_phase%7d"><span style="text-decoration:overline">PCH_PHASE</span></a></td>
<td>A gated 1 MiHz clock, which goes high when WRITE_PHASE (T7) goes high, and low when
<span style="text-decoration:overline">EXEC_PHASE</span> (T2) and CLK (T10) go low.<br>
During its low phase, this clock is responsible for precharging the dynamic NMOS logic in the ALU that produces the
new values for the ALU flags, and also for precharging the dynamic NMOS logic that produces the new PC and SP.<br>
The CPU can stop this clock by driving <span style="text-decoration:overline">HALT</span> (T11) low, in which case it
stays permanently low. This is the only clock that goes into the CPU that has no inverse counterpart.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
<span style="text-decoration:overline">PCH_PHASE</span>:    ‾‾|______________|‾‾‾‾‾
</pre></td>
</tr><tr>
<td>T9</td>
<td>I</td>
<td><span style="text-decoration:overline">CLK</span></td>
<td><a href="/sm83_map/?wires=0&view=w:~%7bclk%7d"><span style="text-decoration:overline">CLK</span></a></td>
<td>A gated 1 MiHz clock, which goes high the moment the CPU outputs the new address at the beginning of a
memory cycle. It is high while the address is valid on the cartridge port and low during the short time when the
address high byte on the cartridge port is usually zeroed.<br>
This is the inverse of CLK (T10). <span style="text-decoration:overline">CLK</span> (T9) and CLK (T10) are the only
clock inputs that are ticking during HALT mode. When the oscillator is stopped, this clock stays permanently low.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
<span style="text-decoration:overline">CLK</span>:          __|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>T10</td>
<td>I</td>
<td>CLK</td>
<td><a href="/sm83_map/?wires=0&view=w:clk">CLK</a></td>
<td>A gated 1 MiHz clock, which goes low the moment the CPU outputs the new address at the beginning of a
memory cycle. It is low while the address is valid on the cartridge port and high during the short time when the
address high byte on the cartridge port is usually zeroed.<br>
The rising edge of this clock is only used by the sequencer logic, for advancing the machine cycle and for some
interrupt processing.<br>
This is the inverse of <span style="text-decoration:overline">CLK</span> (T9).
<span style="text-decoration:overline">CLK</span> (T9) and CLK (T10) are the only clock inputs that are ticking
during HALT mode. When the oscillator is stopped, this clock stays permanently high.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
CLK:          ‾‾|____________________|
</pre></td>
</tr><tr>
<td>T11</td>
<td>O</td>
<td><span style="text-decoration:overline">HALT</span></td>
<td><a href="/sm83_map/?wires=0&view=w:~%7bhalt%7d"><span style="text-decoration:overline">HALT</span></a></td>
<td>CPU can drive this low to disable most of the clocks fed to itself. <span style="text-decoration:overline">CLK</span>
(T9) and CLK (T10) are the only clocks that are not turned off when this signal gets driven low.<br>
When PWRON_RESET (T13) is asserted during power-on-reset, <span style="text-decoration:overline">HALT</span> is
initialized to low state, so most CPU clocks are disabled. The CPU must NOT switch this signal to high immediately
after reset, otherwise SYS_RESET (T12) (generated by <a href="/dmg_cpu_b_map/?view=c:afer">AFER</a>) and the
synchronous peripheral resets (<span style="text-decoration:overline">RESET2</span>, APU_RESETn, PPU_RESETn, ...)
will never be deasserted. The CPU must wait until CLK_READY (T15) (generated by
<a href="/dmg_cpu_b_map/?view=c:taba">TABA</a>) gets high. This happens when the DIV register is half run through, which
takes about 32 milliseconds. The CPU pulls <span style="text-decoration:overline">HALT</span> (T11) high when
CLK_READY (T15) is high and SYS_RESET (T12) is low, but delayed by one CLK rising edge. I assume this mechanism is
there to assure the crystal oscillator is stabilized.<br>
The same mechanism is used when the system wakes up from STOP mode. When the crystal oscillator gets disabled by
driving <span style="text-decoration:overline">STOP</span> (T14) low, the DIV register gets reset to zero, so it will
take the same ~32 ms.<br>
When the CPU executes a HALT instruction and none of the enabled interrupts are pending, then the CPU will pull
<span style="text-decoration:overline">HALT</span> (T11) low to disable most of its clocks. When waking up from HALT
mode (due to an interrupt), the CPU will pull <span style="text-decoration:overline">HALT</span> (T11) high on the
next CLK rising edge, which re-enables all the other clocks.<br>
Changes to the <span style="text-decoration:overline">HALT</span> output are always synchonized to the rising edge of
CLK (T10).<br>
<i>TODO: Test if an externally clocked SERIAL interrupt can bypass the 32 ms period when resuming from STOP mode.</i></td>
</tr><tr>
<td>T12</td>
<td>I</td>
<td>SYS_RESET</td>
<td><a href="/sm83_map/?wires=0&view=w:sys_reset">SYS_RESET</a></td>
<td>Active-high system reset input. Supposed to be synchronized to the rising edge of CLK (T10).<br>
The program counter (PC) and the interrupt enable register (IE) are both reset to 0 by this reset. Also the sequencer
state is reset to perform an initial instruction fetch.<br>
Nothing else is being reset in the CPU. Other registers will have random values, including the instruction register.
This means the CPU can execute a random instruction in parallel to the initial fetch cycle. However, it can't execute
any jumps or memory accesses (except the instruction fetch), because no instruction encodes these actions on M cycle 7
(which is the initial state).</td>
</tr><tr>
<td>T13</td>
<td>I</td>
<td>PWRON_RESET</td>
<td><a href="/sm83_map/?wires=0&view=w:pwron_reset">PWRON_RESET</a></td>
<td>Active-high power-on reset input. Fed directly from
<a href="/dmg_cpu_b_map/?view=c:~%7breset%7d&mark%5b0%5d=-145.35,238.34"><span style="text-decoration:overline">RESET</span> input pad</a>.<br>
This reset is necessary on power-on to initialize the state of the <span style="text-decoration:overline">HALT</span> (T11)
output to low and the <span style="text-decoration:overline">STOP</span> (T14) output to high, so that the crystal
oscillator gets enabled. It resets nothing else. SYS_RESET (T12) is used to bring the CPU into a valid initial state
once CLK/<span style="text-decoration:overline">CLK</span> (T10/T9) are ticking.</td>
</tr><tr>
<td>T14</td>
<td>O</td>
<td><span style="text-decoration:overline">STOP</span></td>
<td><a href="/sm83_map/?wires=0&view=w:~%7bstop%7d"><span style="text-decoration:overline">STOP</span></a></td>
<td>When CPU drives this low, the <a href="/dmg_cpu_b_map/?view=c:ck1_ck2">crystal oscillator</a>
gets disabled to save power. This happens during STOP mode. <span style="text-decoration:overline">HALT</span> (T11)
will also be low during STOP mode.<br>
A change to <span style="text-decoration:overline">STOP</span> from high to low will always be synchonized to the rising
edge of CLK (T10). A change from low to high happens immediately when WAKE (B25) is high.</td>
</tr><tr>
<td>T15</td>
<td>I</td>
<td>CLK_READY</td>
<td><a href="/sm83_map/?wires=0&view=w:clk_ready">CLK_READY</a></td>
<td>On power-on reset or when waking up from STOP mode, this signal gets high after about 32 milliseconds to signal
to the CPU that the clocks are stable. The CPU will acknowledge this signal by pulling
<span style="text-decoration:overline">HALT</span> (T11) high, which in turn deasserts CLK_READY. See description of
<span style="text-decoration:overline">HALT</span> (T11) for more details.</td>
</tr><tr>
<td>T16</td>
<td>I</td>
<td>NMI</td>
<td><a href="/sm83_map/?wires=0&view=w:nmi">NMI</a></td>
<td>Directly connected to <a href="/dmg_cpu_b_map/?view=c:~%7bnmi%7d&mark%5b0%5d=-41.91,132.19">an input
pad</a> at the top of the die, which is not bonded. This is the non-maskable interrupt of the CPU.</td>
</tr><tr>
<td>R1</td>
<td>O</td>
<td>RD</td>
<td><a href="/sm83_map/?wires=0&view=w:rd">RD</a></td>
<td>Active-high memory read signal from CPU. In contrast to the read signal on the cartridge connector, the CPU its read
signal is only asserted when the CPU actually reads data. It is synchronous to the DATA_PHASE (T5) clock. When the CPU is
reading from its internal IE register on address 0xFFFF, the read signal is also asserted.<br>
Although the read signal is only asserted during T3 and T4, data on the bus is sampled for much longer (see diagram below).
The sampling doesn't happen on an edge, it happens while EXEC_PHASE (T3) is high. If at any time during this sampling
period a data bit on the bus is low, then it will be read as low, even if it flips back to high later. So basically,
the read operation works like an AND operation over time. When there is the value 0xFC on the data bus at T2 and the value
0x3F at T4, then the CPU will read the value 0x3C, because 0xFC &and; 0x3F = 0x3C. The data bus is always precharged to
0xFF during the first half-cycle of T1.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
RD:           ___________|‾‾‾‾‾‾‾‾‾‾‾|
D[0..7]:      ‾‾|XXXXXXXXXXXXXXXXXXXX|
</pre></td>
</tr><tr>
<td>R2</td>
<td>O</td>
<td>WR</td>
<td><a href="/sm83_map/?wires=0&view=w:wr">WR</a></td>
<td>Active-high memory write signal from CPU. The write signal is synchronous to the EXEC_PHASE (T3) clock. When the CPU
is writing to its internal IE register on address 0xFFFF, the write signal is also asserted.<br>
Although the write signal is already asserted at the falling edge of T1, the data is only valid while DATA_PHASE (T5)
is high (which is during T3 and T4). The data bus is always precharged to 0xFF during the first half-cycle of T1. At
any other time, the data is only actively driven low. This means the same AND rule applies like during a read operation:
If by accident, someone is driving a low bit onto the data bus (for example at T2), then this bit will stay low until
the precharging at the beginning of the next memory cycle happens.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
WR:           __|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
D[0..7]:      ‾‾‾‾‾‾‾‾‾‾‾|XXXXXXXXXXX|
</pre></td>
</tr><tr>
<td>R3</td>
<td>I</td>
<td><span style="text-decoration:overline">OE</span></td>
<td><a href="/sm83_map/?wires=0&view=w:~%7boe%7d"><span style="text-decoration:overline">OE</span></a></td>
<td>Active-low output enable. When high, then D[0..7] (B1-B8) and A[0..15] (B9-B24) are disabled and not
actively driven by the CPU, and RD (R1) is disabled by being driven low. WR (R2) is not affected.<br>
This is only used when test mode T1 is enabled.</td>
</tr><tr>
<td>R4</td>
<td>I</td>
<td>INTERNAL_ACCESS</td>
<td><a href="/sm83_map/?wires=0&view=w:internal_access">INTERNAL_ACCESS</a></td>
<td>When high, then the MREQ (R7) output is inhibited and stays low.<br>
The circuit outside the CPU drives this input high when address bus is 0xFEXX or 0xFFXX.</td>
</tr><tr>
<td>R5</td>
<td>I</td>
<td>SHADOW_ACCESS</td>
<td><a href="/sm83_map/?wires=0&view=w:shadow_access">SHADOW_ACCESS</a></td>
<td>When high while SHADOW_OVERRIDE (R6) is low, then the MREQ (R7) output is inhibited and stays low.<br>
The circuit outside the CPU drives this input high when address bus is 0x00XX and boot ROM is still visible.</td>
</tr><tr>
<td>R6</td>
<td>I</td>
<td>SHADOW_OVERRIDE</td>
<td><a href="/sm83_map/?wires=0&view=w:shadow_override">SHADOW_OVERRIDE</a></td>
<td>When high, this disables the function of the SHADOW_ACCESS (R5) input.<br>
This is only used when test mode T2 is enabled.</td>
</tr><tr>
<td>R7</td>
<td>O</td>
<td>MREQ</td>
<td><a href="/sm83_map/?wires=0&view=w:mreq">MREQ</a></td>
<td>Active-high external memory request. High during external memory cycles (read or write). This causes one of the
chip select signals
(<a href="/dmg_cpu_b_map/?view=c:~%7bcs%7d"><span style="text-decoration:overline">CS</span></a>,
<a href="/dmg_cpu_b_map/?view=c:~%7bmcs%7d"><span style="text-decoration:overline">MCS</span></a>,
<a href="/dmg_cpu_b_map/?view=c:a15">A15</a>) to be asserted in the right moment. Low if no memory cycle is going on,
otherwise the chip select would be asserted even if RD (R1) and WR (R2) are low. During write cycles, this signal
is also needed for driving the internal data bus onto the external I/O pins. During read cycles, this signal is also
needed for latching the external I/O pins and driving the latched data onto the chip internal data bus. When
INTERNAL_ACCESS (R4) or SHADOW_ACCESS (R5) is high, the CPU keeps this signal low, allowing internal components
(HRAM, OAM, boot ROM, FFxx registers) to drive the data bus.<br>
To be precise, MREQ is asserted during a memory cycle when this is true:<br>
&not;INTERNAL_ACCESS &and; (&not;SHADOW_ACCESS &or; SHADOW_OVERRIDE)
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
MREQ:         __|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R8</td>
<td>-</td>
<td>-</td>
<td><a href="/sm83_map/?wires=0&view=w:vdd">VDD</a></td>
<td>Not connected. Internally connected to VDD.</td>
</tr><tr>
<td>R9</td>
<td>-</td>
<td>-</td>
<td><a href="/sm83_map/?wires=0&view=w:vdd">VDD</a></td>
<td>Not connected. Internally connected to VDD.</td>
</tr><tr>
<td>R10</td>
<td>-</td>
<td>-</td>
<td><a href="/sm83_map/?wires=0&view=w:gnd">GND</a></td>
<td>Not connected. Internally connected to GND.</td>
</tr><tr>
<td>R11</td>
<td>-</td>
<td>-</td>
<td><a href="/sm83_map/?wires=0&view=w:gnd">GND</a></td>
<td>Not connected. Internally connected to GND.</td>
</tr><tr>
<td>R12</td>
<td>-</td>
<td>-</td>
<td><a href="/sm83_map/?wires=0&view=w:gnd">GND</a></td>
<td>Not connected. Internally connected to GND.</td>
</tr><tr>
<td>R13</td>
<td>O</td>
<td>FFXX</td>
<td><a href="/sm83_map/?wires=0&view=w:ffxx">FFXX</a></td>
<td>Not connected. High when A[15..8] (B9-B16) are high.</td>
</tr><tr>
<td>R14</td>
<td>O</td>
<td>INTA[0]</td>
<td><a href="/sm83_map/?wires=0&view=w:inta%5b0%5d">INTA[0]</a></td>
<td>Active-high. Acknowledges IRQ0 (V-Blank).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
INTA[0]:      _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R15</td>
<td>I</td>
<td>INT[0]</td>
<td><a href="/sm83_map/?wires=0&view=w:int%5b0%5d">INT[0]</a></td>
<td>Active-high. Triggers IRQ0 (V-Blank).</td>
</tr><tr>
<td>R16</td>
<td>O</td>
<td>INTA[1]</td>
<td><a href="/sm83_map/?wires=0&view=w:inta%5b1%5d">INTA[1]</a></td>
<td>Active-high. Acknowledges IRQ1 (Status).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
INTA[1]:      _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R17</td>
<td>I</td>
<td>INT[1]</td>
<td><a href="/sm83_map/?wires=0&view=w:int%5b1%5d">INT[1]</a></td>
<td>Active-high. Triggers IRQ1 (Status).</td>
</tr><tr>
<td>R18</td>
<td>O</td>
<td>INTA[2]</td>
<td><a href="/sm83_map/?wires=0&view=w:inta%5b2%5d">INTA[2]</a></td>
<td>Active-high. Acknowledges IRQ2 (Timer).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
INTA[2]:      _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R19</td>
<td>I</td>
<td>INT[2]</td>
<td><a href="/sm83_map/?wires=0&view=w:int%5b2%5d">INT[2]</a></td>
<td>Active-high. Triggers IRQ2 (Timer).</td>
</tr><tr>
<td>R20</td>
<td>O</td>
<td>INTA[3]</td>
<td><a href="/sm83_map/?wires=0&view=w:inta%5b3%5d">INTA[3]</a></td>
<td>Active-high. Acknowledges IRQ3 (Serial).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
INTA[3]:      _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R21</td>
<td>I</td>
<td>INT[3]</td>
<td><a href="/sm83_map/?wires=0&view=w:int%5b3%5d">INT[3]</a></td>
<td>Active-high. Triggers IRQ3 (Serial).</td>
</tr><tr>
<td>R22</td>
<td>O</td>
<td>INTA[4]</td>
<td><a href="/sm83_map/?wires=0&view=w:inta%5b4%5d">INTA[4]</a></td>
<td>Active-high. Acknowledges IRQ4 (Joypad).
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
INTA[4]:      _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R23</td>
<td>I</td>
<td>INT[4]</td>
<td><a href="/sm83_map/?wires=0&view=w:int%5b4%5d">INT[4]</a></td>
<td>Active-high. Triggers IRQ4 (Joypad).</td>
</tr><tr>
<td>R24</td>
<td>O</td>
<td>INTA[5]</td>
<td><a href="/sm83_map/?wires=0&view=w:inta%5b5%5d">INTA[5]</a></td>
<td>Active-high. Acknowledges IRQ5. Not connected.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
INTA[5]:      _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R25</td>
<td>I</td>
<td>INT[5]</td>
<td><a href="/sm83_map/?wires=0&view=w:int%5b5%5d">INT[5]</a></td>
<td>Active-high. Triggers IRQ5. Hardwired to GND.</td>
</tr><tr>
<td>R26</td>
<td>O</td>
<td>INTA[6]</td>
<td><a href="/sm83_map/?wires=0&view=w:inta%5b6%5d">INTA[6]</a></td>
<td>Active-high. Acknowledges IRQ6. Not connected.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
INTA[6]:      _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R27</td>
<td>I</td>
<td>INT[6]</td>
<td><a href="/sm83_map/?wires=0&view=w:int%5b6%5d">INT[6]</a></td>
<td>Active-high. Triggers IRQ6. Hardwired to GND.</td>
</tr><tr>
<td>R28</td>
<td>O</td>
<td>INTA[7]</td>
<td><a href="/sm83_map/?wires=0&view=w:inta%5b7%5d">INTA[7]</a></td>
<td>Active-high. Acknowledges IRQ7. Not connected.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
INTA[7]:      _________________|‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R29</td>
<td>I</td>
<td>INT[7]</td>
<td><a href="/sm83_map/?wires=0&view=w:int%5b7%5d">INT[7]</a></td>
<td>Active-high. Triggers IRQ7. Hardwired to GND.</td>
</tr><tr>
<td>R30</td>
<td>O</td>
<td>PREFIX_CB</td>
<td><a href="/sm83_map/?wires=0&view=w:ctl_op_cb_prefix">CTL_OP_CB_PREFIX</a></td>
<td>Not connected. High when the currently executed opcode is 0xCB.
<pre>
Ticks:       : T1  : T2  : T3  : T4  :
CLK4MiHz:     ‾‾|__|‾‾|__|‾‾|__|‾‾|__
PREFIX_CB:    __|‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾|
</pre></td>
</tr><tr>
<td>R31</td>
<td>I</td>
<td>TEST_FREEZE</td>
<td><a href="/sm83_map/?wires=0&view=w:test_freeze">TEST_FREEZE</a></td>
<td>Hardwired to GND. I assume this was used for testing the CPU. When pulled high, the current M cycle in the
sequencer is set to 7, and the TABLE_CB and IN_INTR inputs of the first instruction decoder stage are temporarily
overriden to be true, which is an invalid state. In this state the CPU would just do nothing until TEST_FREEZE
is released again.</td>
</tr><tr>
<td>R32</td>
<td>O</td>
<td>INT_ENTRY</td>
<td><a href="/sm83_map/?wires=0&view=w:int_entry">INT_ENTRY</a></td>
<td>Not connected. High while an interrupt entry sequence is executed.<br>
Changes state on rising edges of CLK (T10).</td>
</tr><tr>
<td>B1</td>
<td>I/O</td>
<td>D[0]</td>
<td><a href="/sm83_map/?wires=0&view=w:d%5b0%5d">D[0]</a></td>
<td>Data bus D[0].</td>
</tr><tr>
<td>B2</td>
<td>I/O</td>
<td>D[1]</td>
<td><a href="/sm83_map/?wires=0&view=w:d%5b1%5d">D[1]</a></td>
<td>Data bus D[1].</td>
</tr><tr>
<td>B3</td>
<td>I/O</td>
<td>D[2]</td>
<td><a href="/sm83_map/?wires=0&view=w:d%5b2%5d">D[2]</a></td>
<td>Data bus D[2].</td>
</tr><tr>
<td>B4</td>
<td>I/O</td>
<td>D[3]</td>
<td><a href="/sm83_map/?wires=0&view=w:d%5b3%5d">D[3]</a></td>
<td>Data bus D[3].</td>
</tr><tr>
<td>B5</td>
<td>I/O</td>
<td>D[4]</td>
<td><a href="/sm83_map/?wires=0&view=w:d%5b4%5d">D[4]</a></td>
<td>Data bus D[4].</td>
</tr><tr>
<td>B6</td>
<td>I/O</td>
<td>D[5]</td>
<td><a href="/sm83_map/?wires=0&view=w:d%5b5%5d">D[5]</a></td>
<td>Data bus D[5].</td>
</tr><tr>
<td>B7</td>
<td>I/O</td>
<td>D[6]</td>
<td><a href="/sm83_map/?wires=0&view=w:d%5b6%5d">D[6]</a></td>
<td>Data bus D[6].</td>
</tr><tr>
<td>B8</td>
<td>I/O</td>
<td>D[7]</td>
<td><a href="/sm83_map/?wires=0&view=w:d%5b7%5d">D[7]</a></td>
<td>Data bus D[7].</td>
</tr><tr>
<td>B9</td>
<td>O</td>
<td>A[15]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b15%5d">A[15]</a></td>
<td>Address bus A[15].</td>
</tr><tr>
<td>B10</td>
<td>O</td>
<td>A[14]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b14%5d">A[14]</a></td>
<td>Address bus A[14].</td>
</tr><tr>
<td>B11</td>
<td>O</td>
<td>A[13]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b13%5d">A[13]</a></td>
<td>Address bus A[13].</td>
</tr><tr>
<td>B12</td>
<td>O</td>
<td>A[12]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b12%5d">A[12]</a></td>
<td>Address bus A[12].</td>
</tr><tr>
<td>B13</td>
<td>O</td>
<td>A[11]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b11%5d">A[11]</a></td>
<td>Address bus A[11].</td>
</tr><tr>
<td>B14</td>
<td>O</td>
<td>A[10]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b10%5d">A[10]</a></td>
<td>Address bus A[10].</td>
</tr><tr>
<td>B15</td>
<td>O</td>
<td>A[9]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b9%5d">A[9]</a></td>
<td>Address bus A[9].</td>
</tr><tr>
<td>B16</td>
<td>O</td>
<td>A[8]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b8%5d">A[8]</a></td>
<td>Address bus A[8].</td>
</tr><tr>
<td>B17</td>
<td>O</td>
<td>A[7]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b7%5d">A[7]</a></td>
<td>Address bus A[7].</td>
</tr><tr>
<td>B18</td>
<td>O</td>
<td>A[6]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b6%5d">A[6]</a></td>
<td>Address bus A[6].</td>
</tr><tr>
<td>B19</td>
<td>O</td>
<td>A[5]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b5%5d">A[5]</a></td>
<td>Address bus A[5].</td>
</tr><tr>
<td>B20</td>
<td>O</td>
<td>A[4]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b4%5d">A[4]</a></td>
<td>Address bus A[4].</td>
</tr><tr>
<td>B21</td>
<td>O</td>
<td>A[3]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b3%5d">A[3]</a></td>
<td>Address bus A[3].</td>
</tr><tr>
<td>B22</td>
<td>O</td>
<td>A[2]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b2%5d">A[2]</a></td>
<td>Address bus A[2].</td>
</tr><tr>
<td>B23</td>
<td>O</td>
<td>A[1]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b1%5d">A[1]</a></td>
<td>Address bus A[1].</td>
</tr><tr>
<td>B24</td>
<td>O</td>
<td>A[0]</td>
<td><a href="/sm83_map/?wires=0&view=w:a%5b0%5d">A[0]</a></td>
<td>Address bus A[0].</td>
</tr><tr>
<td>B25</td>
<td>I</td>
<td>WAKE</td>
<td><a href="/sm83_map/?wires=0&view=w:wake">WAKE</a></td>
<td>Wakes CPU from STOP mode. Rising this signal immediately causes the CPU to pull
<span style="text-decoration:overline">STOP</span> (T14) high, which enables the crystal oscillator. Has no effect
when <span style="text-decoration:overline">STOP</span> is already high.</td>
</tr></table></main>
<footer><hr>
<p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"></a><br>This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.</p>
</footer></body>
</html>
