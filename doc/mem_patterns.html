<html>
<head>
<title>GameBoy Memory Access Patterns</title>
</head>
<body>
<h1>GameBoy Memory Access Patterns</h1>
<h2>Setup</h2>
<p>For the first few pictures a Hantek 6022BL oscilloscope/logic analyzer was used. (In digital mode,
basically a Chineese Saleae ripoff.) The sample rate is 24M/s. Needless to say, this cheap device doesn't
have decent Schmitt triggers on the logic inputs. When the probed voltage is in the range of 1.3V and 1.7V,
the displayed level randomly flickers between high and low. This effect is visible during power up of the
GameBoy, when the signals are slowly rising.</p>
<p>Later I got another (much cheaper) logic analyzer from China that claims to be a Saleae, but it isn't.
Although it only costs about a third of the Hantek, it is actually able to utilize all 16 inputs! All
recordings with 16M/s, 25M/s and 32M/s are done with this new one; the 24M/s ones are done with the Hantek.
The level also flickers between high and low when the probed voltage is in the range of 1.3V and 1.5V.</p>
<p>An EverDrive cartridge was used for running the test code. This means the state and timing of the data
lines when reading from the cartridge may not be representative for an original cartridge. Also, when this
cartridge is plugged in during power up of the GameBoy, the ramp up time of the reset line drops from ~50ms
to ~40ms. Maybe there is a pull up resistor in the cartridge causing this.</p>
<h2>Power On event</h2>
<p>After flipping the power switch to the <i>on</i> position, the clock, #write and #cs signals, address
and data lines are ramping up. The #read signal stays low. The #reset line is delayed by about 10ms and
takes about 50ms to reach its peak.</p>
<p><img src="img/power_on.png"><br>
<i><u>Picture 1</u> (24M/s)<br>
1: After power on, signals are ramping up<br>
2: Boot ROM zero-initializes VRAM<br>
3: Boot ROM configures peripherals and loads/expands Nintendo logo from cartridge to VRAM<br>
4: Boot ROM continues w/o accessing cartridge (scrolling logo down)<br>
5: Approximated reset ramp (I don't have a relation between this logic diagram and the oscilloscope screen
below, so take this with a grain of salt)</i></p>
<p><img src="img/reset_rise.png"><br>
<i><u>Picture 2</u><br>
Rising #reset line</i></p>
<h2>Boot ROM external bus access</h2>
<p>The boot ROM runs for exactly 57358 clock cycles before any of the lines (except clock) is changing. For now,
I assume a clock cycle starts and ends with a rising edge, although this is probably wrong. The very first cycle
is an exception, because the #clock line is already high when the cycle starts, there is no rising edge. That is
why the measurement in <i>Picture 1</i> displays only 57357 full cycles. This is the code that gets executed
during this time:</p>
<p><pre>
   0:   31 fe ff        ld sp,0xfffe   ; 3 cycles
   3:   af              xor a          ; 1
   4:   21 ff 9f        ld hl,0x9fff   ; 3                           _
   7:   32              ldd (hl),a     ; 2                            \
   8:   cb 7c           bit 7,h        ; 2                             \--&gt; loop: 57343 cycles
   a:   20 fb           jr nz,0x0007   ; 3 when jumping; 2 otherwise __/
   c:   21 26 ff        ld hl,0xff26   ; 3
   f:   0e 11           ld c,0x11      ; 2
  11:   3e 80           ld a,0x80      ; 2 cycles  &lt;-- ends at cycle #57357
  13:   32              ldd (hl),a     ; 2         &lt;-- ends at cycle #57359, address lines reflect 0xff26
  14:   e2              ldh (c),a
  15:   0c              inc c
  16:   3e f3           ld a,0xf3
  18:   e2              ldh (c),a
  19:   32              ldd (hl),a
  1a:   3e 77           ld a,0x77
  1c:   77              ld (hl),a
  1d:   3e fc           ld a,0xfc
  1f:   e0 47           ldh (0x47),a
</pre></p>
<p>The VRAM access during the loop at 0x7-0xA is not visible on the external memory bus. The first thing that
can be seen on the externel bus is the operation at 0x13, which writes 0x80 into the APU register 0xff26. The
instruction fetch happens at cycle #57358, the write operation at #57359. During this operation, the address
lines reflect the actual address (0xff26). The #read signal may glitch sometimes for a few nanoseconds. In the
picture below, these glitches measure 41.67ns. When I use a sample rate of 100M/s, they go down to 20ns and
sometimes even 10ns. The data lines stay unchanged and #write stays high (deasserted). All reads and writes to
registers and HRAM (0xff??) seem to behave this way.</p>
<p><img src="img/boot_rom_wr_ff26.png"><br>
<i><u>Picture 3</u> (24M/s)<br>
Boot ROM instructions at address 0x13 and 0x14</i></p>
<p><img src="img/boot_rom-rw_overview.png"><br>
<i><u>Picture 4</u> (24M/s)<br>
1: Boot ROM execution w/o accessing cartridge ROM<br>
2: Boot ROM comparing Nintendo logo (executing at addresses 0xe0...0xf0)<br>
3: Boot ROM checking header sum (executing 0xf1...0xfb)<br>
4: Executing code in cartridge ROM (startup code of <a href="../test_roms/rom-rw.gb">rom-rw.gb</a>: <a href="../test_roms/common.s">common.s</a>)<br>
5: Executing code in HRAM (main loop of <a href="../test_roms/rom-rw.gb">rom-rw.gb</a>: <a href="../test_roms/rom-rw.s">rom-rw.s</a>)</i></p>
<h2>Bus Overview</h2>
<p>The CPU is master of five distinct memory busses.</p>
<p><table border="1">
<tr>
<th><p><i>mapping</i></p></th>
<th bgcolor="#ffe0e0"><p>External Bus</p></th>
<th bgcolor="#ffffe0"><p>Internal Bus</p></th>
<th bgcolor="#e0e0ff"><p>External Video Bus</p></th>
<th bgcolor="#e0ffff"><p>Internal Video Bus</p></th>
<th bgcolor="#e0ffe0"><p>Hidden Bus</p></th>
</tr><tr>
<th><p>Boot ROM<br>0x0000-0x00FF</p></th>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td align="center"><p>X <i>(*)</i></p></td>
</tr><tr>
<th><p>Cartridge ROM<br>0x0000-0x7FFF</p></th>
<td align="center"><p>X</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p>Video RAM<br>0x8000-0x9FFF</p></th>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td align="center"><p>X</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p>Cartridge RAM<br>0xA000-0xBFFF</p></th>
<td align="center"><p>X</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p>Work RAM<br>0xC000-0xDFFF</p></th>
<td align="center"><p>X</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p><i>unused area</i><br>0xE000-0xFDFF</p></th>
<td align="center"><p>X <i>(**)</i></p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p>OAM RAM<br>0xFE00-0xFE9F</p></th>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td align="center"><p>X</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p><i>unused area</i><br>0xFEA0-0xFEFF</p></th>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td align="center"><p>?</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p>Registers<br>0xFF00-0xFF7F</p></th>
<td><p>&nbsp;</p></td>
<td align="center"><p>X</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p>Work &amp; Stack RAM<br>0xFF80-0xFFFE</p></th>
<td><p>&nbsp;</p></td>
<td align="center"><p>X</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
</tr><tr>
<th><p>IE Register<br>0xFFFF</p></th>
<td><p>&nbsp;</p></td>
<td align="center"><p>X</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
</tr>
</table>
<i><u>Table 1</u><br>
(*): 0x0000-0x00FF is only mapped to the hidden bus during boot;
gets cut off when boot ROM writes 0x01 to register 0xFF50<br>
(**): 0xE000-0xFDFF is often called the WRAM echo or shadow area; actually the cartridge
RAM may also respond here, which could lead to short circuits during read operations</i></p>
<p>On the external bus, A15 serves as a low active ROM chip select. It will only switch to low when the
cartridge ROM gets accessed. It will immediatly switch back to high at the end of the read/write operation. The
other address lines (A0-A14) keep their state until another bus access is causing them to change. The #cs signal
serves as a chip select for both RAMs on the external bus (WRAM and cartridge RAM). It behaves the same way as
A15 does for the cartridge ROM. The WRAM uses A14 as a secondary, high active chip select. The cartridge RAM uses
A13 as a secondary, high active chip select. Still, A13 and A14 act like the other address lines, not like the
primary chip selects (#cs and A15). When accesing the address range 0xE000-0xFDFF, both A13 and A14 are high
and therefore both RAMs are active.</p>
<p>When #read is low, D0-D7 are always configured as inputs (driven by the cartridge or WRAM or pulled up by
a pull-up resistor). When #read is high and a chip select (#cs or A15) is low, D0-D7 are always configured as
outputs (driven by the GameBoy). There is a short switching period when #read and both chip selects are high.</p>
<p><table border="1" bgcolor="#ffe0e0">
<tr>
<th><p><i>&amp;&amp;</i></p></th>
<th><p>!(#cs) &amp;&amp; (A15)</p></th>
<th><p>(#cs) &amp;&amp; (A15)</p></th>
<th><p>(#cs) &amp;&amp; !(A15)</p></th>
</tr><tr>
<th><p>!(#read)</p></th>
<td align="center"><p>input &rarr;<br>&nbsp;</p></td>
<td align="center"><p>&larr; input <i>(*)</i> &rarr;<br>&darr;</p></td>
<td align="center"><p>&larr; input<br>&nbsp;</p></td>
</tr><tr>
<th><p>(#read)</p></th>
<td align="center"><p>&nbsp;<br>output &rarr;</p></td>
<td align="center"><p>&uarr;<br>&larr; undefined &rarr;</p></td>
<td align="center"><p>&nbsp;<br>&larr; output</p></td>
</tr>
</table>
<i><u>Table 2</u><br>
Arrows: Indicate legal state changes<br>
(*): The "default" state, when cartridge and WRAM are not accessed</i></p>
<p>There are two peripherals that also gain access to some of the busses: The PPU and the DMA. The PPU has
the highest priority, the CPU has the lowest.</p>
<p><table border="1">
<tr>
<th><p><i>has access to bus<br>(ordered by priority)</i></p></th>
<th bgcolor="#e0ffe0"><p>Hidden Bus</p></th>
<th bgcolor="#ffe0e0"><p>External Bus</p></th>
<th bgcolor="#ffffe0"><p>Internal Bus</p></th>
<th bgcolor="#e0e0ff"><p>External Video Bus</p></th>
<th bgcolor="#e0ffff"><p>Internal Video Bus</p></th>
</tr><tr>
<th><p>PPU</p></th>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td><p>&nbsp;</p></td>
<td align="center"><p>X (ro)</p></td>
<td align="center"><p>X (ro)</p></td>
</tr><tr>
<th><p>DMA</p></th>
<td align="center"><p>?</p></td>
<td align="center"><p>X (ro)</p></td>
<td align="center"><p>?</p></td>
<td align="center"><p>X (ro)</p></td>
<td align="center"><p>X (wo)</p></td>
</tr><tr>
<th><p>CPU</p></th>
<td align="center"><p>X</p></td>
<td align="center"><p>X</p></td>
<td align="center"><p>X</p></td>
<td align="center"><p>X</p></td>
<td align="center"><p>X</p></td>
</tr>
</table>
<i><u>Table 3</u></i></p>
<p><table border="1" bgcolor="#ffe0e0">
<tr>
<th><p><i>signals visible on<br>external bus during<br>CPU mem access</i></p></th>
<th><p>#write</p></th>
<th><p>#read</p></th>
<th><p>#cs</p></th>
<th><p>A15</p></th>
<th><p>A0-A14</p></th>
<th><p>D0-D7 direction</p></th>
<th><p>D0-D7 output buffer</p></th>
</tr><tr>
<th bgcolor="#e0ffe0"><p>Hidden Bus (*)</p></th>
<td><p>high</p></td>
<td><p>low</p></td>
<td><p>high</p></td>
<td><p>high</p></td>
<td><p>no change</p></td>
<td><p>input</p></td>
<td><p>no change</p></td>
</tr><tr>
<th bgcolor="#ffe0e0"><p>External Bus</p></th>
<td><p>w: low<br>r: high</p></td>
<td><p>w: high<br>r: low</p></td>
<td><p>high</p></td>
<td><p>low</p></td>
<td><p>change</p></td>
<td><p>w: output<br>r: input</p></td>
<td><p>w: change<br>r: no change</p></td>
</tr><tr>
<th bgcolor="#ffffe0"><p>Internal Bus</p></th>
<td><p>high</p></td>
<td><p>w: low (glitchy)<br>r: low</p></td>
<td><p>high</p></td>
<td><p>high</p></td>
<td><p><b>change</b></p></td>
<td><p>input</p></td>
<td><p>no change</p></td>
</tr><tr>
<th bgcolor="#e0e0ff"><p>External Video Bus</p></th>
<td><p>high</p></td>
<td><p>w: low (glitchy)<br>r: low</p></td>
<td><p>high</p></td>
<td><p>high</p></td>
<td><p>no change</p></td>
<td><p>input</p></td>
<td><p>no change</p></td>
</tr><tr>
<th bgcolor="#e0ffff"><p>Internal Video Bus</p></th>
<td><p>high</p></td>
<td><p>w: low (glitchy)<br>r: low</p></td>
<td><p>high</p></td>
<td><p>high</p></td>
<td><p><b>change</b></p></td>
<td><p>input</p></td>
<td><p>no change</p></td>
</tr>
</table>
<i><u>Table 4</u><br>
Signals visible on external bus when CPU accesses any of the five busses (while DMA is not accessing WRAM or cartridge)<br>
(*): Write access on hidden bus not tested yet</i></p>
<p><table border="1" bgcolor="#e0e0ff">
<tr>
<th><p><i>signals visible on<br>ext. video bus during<br>CPU mem access</i></p></th>
<th><p>#vwrite</p></th>
<th><p>#vread</p></th>
<th><p>#vcs</p></th>
<th><p>VA0-VA12</p></th>
<th><p>VD0-VD7 direction</p></th>
<th><p>VD0-VD7 output buffer</p></th>
</tr><tr>
<th bgcolor="#e0ffe0"><p>Hidden Bus (*)</p></th>
<td><p>high</p></td>
<td><p>low</p></td>
<td><p>high</p></td>
<td><p><b>change</b></p></td>
<td><p>input</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#ffe0e0"><p>External Bus</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>high</p></td>
<td><p><b>change</b></p></td>
<td><p>input</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#ffffe0"><p>Internal Bus</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>high</p></td>
<td><p><b>change</b></p></td>
<td><p>input</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#e0e0ff"><p>External Video Bus</p></th>
<td><p>w: low<br>r: high</p></td>
<td><p>w: high<br>r: low</p></td>
<td><p>low</p></td>
<td><p>change</p></td>
<td><p>w: output<br>r: input</p></td>
<td><p>w: change<br>r: ?</p></td>
</tr><tr>
<th bgcolor="#e0ffff"><p>Internal Video Bus</p></th>
<td><p>high</p></td>
<td><p>low</p></td>
<td><p>high</p></td>
<td><p><b>change</b></p></td>
<td><p>input</p></td>
<td><p>?</p></td>
</tr>
</table>
<i><u>Table 5</u><br>
Signals visible on external video bus when CPU accesses any of the five busses (while PPU and DMA are not accessing VRAM)<br>
(*): Write access on hidden bus not tested yet</i></p>
<p><table border="1" bgcolor="#e0e0ff">
<tr>
<th><p><i>signals visible on<br>ext. video bus during<br>PPU mem access</i></p></th>
<th><p>#vwrite</p></th>
<th><p>#vread</p></th>
<th><p>#vcs</p></th>
<th><p>VA0-VA12</p></th>
<th><p>VD0-VD7 direction</p></th>
</tr><tr>
<th bgcolor="#e0e0ff"><p>External Video Bus</p></th>
<td><p>high</p></td>
<td><p>low</p></td>
<td><p>low</p></td>
<td><p>change</p></td>
<td><p>input (glitchy)</p></td>
</tr><tr>
<th bgcolor="#e0ffff"><p>Internal Video Bus</p></th>
<td colspan="5" align="center"><p>controlled by DMA or CPU</p></td>
</tr>
</table>
<i><u>Table 6</u><br>
Signals visible on external video bus when PPU accesses any of the two busses</i></p>
<p><table border="1" bgcolor="#ffe0e0">
<tr>
<th><p><i>signals visible on<br>external bus during<br>DMA mem access</i></p></th>
<th><p>#write</p></th>
<th><p>#read</p></th>
<th><p>#cs</p></th>
<th><p>A15</p></th>
<th><p>A0-A14</p></th>
<th><p>D0-D7 direction</p></th>
</tr><tr>
<th bgcolor="#e0ffe0"><p>Hidden Bus (*)</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#ffe0e0"><p>External Bus</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#ffffe0"><p>Internal Bus (*)</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#e0e0ff"><p>External Video Bus</p></th>
<td colspan="6" align="center"><p>controlled by CPU</p></td>
</tr><tr>
<th bgcolor="#e0ffff"><p>Internal Video Bus</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
</table>
<i><u>Table 7</u><br>
Signals visible on external bus when DMA accesses any of the three/five (*) busses<br>
(*): Not tested yet if DMA has access to hidden or internal bus</i></p>
<p><table border="1" bgcolor="#e0e0ff">
<tr>
<th><p><i>signals visible on<br>ext. video bus during<br>DMA mem access</i></p></th>
<th><p>#vwrite</p></th>
<th><p>#vread</p></th>
<th><p>#vcs</p></th>
<th><p>VA0-VA12</p></th>
<th><p>VD0-VD7 direction</p></th>
</tr><tr>
<th bgcolor="#e0ffe0"><p>Hidden Bus (*)</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#ffe0e0"><p>External Bus</p></th>
<td colspan="5" align="center"><p>controlled by PPU or CPU</p></td>
</tr><tr>
<th bgcolor="#ffffe0"><p>Internal Bus (*)</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#e0e0ff"><p>External Video Bus</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr><tr>
<th bgcolor="#e0ffff"><p>Internal Video Bus</p></th>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
<td><p>?</p></td>
</tr>
</table>
<i><u>Table 8</u><br>
Signals visible on external video bus when DMA accesses any of the three/five (*) busses (while PPU is not accessing VRAM)<br>
(*): Not tested yet if DMA has access to hidden or internal bus</i></p>
<!--
write WRAM:
  950ns clk period:
    140ns-150ns  #rd  low -> high
    480ns        clk  high -> low
    480ns-490ns  #wr  high -> low
    830ns-840ns  #wr  low -> high
    950ns        clk  low -> high
    980ns        #rd  high -> low
-->
<!--
What happens when DMA reads 0xff00? Does it access the 0xe000 (echo) region?
-->
</body>
</html>
