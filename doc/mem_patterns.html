<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GameBoy Memory Access Patterns</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
 img {
  max-width: 100%;
  display:   inline;
 }
 table.default {
  border-top:    1px solid #b2b2b2;
  border-left:   1px solid #b2b2b2;
  border-bottom: 1px solid #4c4c4c;
  border-right:  1px solid #4c4c4c;
 }
 table.default tr th {
   border-top:    1px solid #4c4c4c;
   border-left:   1px solid #4c4c4c;
   border-bottom: 1px solid #b2b2b2;
   border-right:  1px solid #b2b2b2;
 }
 table.default tr td {
   border-top:    1px solid #4c4c4c;
   border-left:   1px solid #4c4c4c;
   border-bottom: 1px solid #b2b2b2;
   border-right:  1px solid #b2b2b2;
 }
 table.center tr td {
   text-align: center;
 }
</style>
</head>
<body>
<h1>GameBoy Memory Access Patterns</h1>
<h2>Setup</h2>
<p>All measurements were done on a DMG-CPU B.</p>
<p>For the first few pictures a Hantek 6022BL oscilloscope/logic analyzer was used. (In digital mode,
basically a Chineese Saleae ripoff.) The sample rate is 24M/s. Needless to say, this cheap device doesn't
have decent Schmitt triggers on the logic inputs. When the probed voltage is in the range of 1.3V and 1.7V,
the displayed level randomly flickers between high and low. This effect is visible during power up of the
GameBoy, when the signals are slowly rising.</p>
<p>Later I got another (much cheaper) logic analyzer from China that claims to be a Saleae, but it isn't.
Although it only costs about a third of the Hantek, it is actually able to utilize all 16 inputs! All
recordings with 16M/s, 25M/s and 32M/s are done with this new one; the 24M/s ones are done with the Hantek.
The level also flickers between high and low when the probed voltage is in the range of 1.3V and 1.5V. This
logic analyzer returns some old buffers when it starts sampling. The beginning of the captured data needs to
be ignored.</p>
<p>An EverDrive cartridge was used for running the test code. This means the state and timing of the data
lines when reading from the cartridge may not be representative for an original cartridge. Also, when this
cartridge is plugged in during power up of the GameBoy, the ramp up time of the reset line drops from ~50ms
to ~40ms. Maybe there is a pull up resistor in the cartridge causing this.</p>
<h2>Power On event</h2>
<p>After flipping the power switch to the <i>on</i> position, the clock, #write and #cs signals, address
and data lines are ramping up. The #read signal stays low. The #reset line is delayed by about 10ms and
takes about 50ms to reach its peak.</p>
<p><img src="img/power_on.png" alt=""><br>
<i><u>Picture 1</u> (24M/s)<br>
1: After power on, signals are ramping up<br>
2: Boot ROM zero-initializes VRAM<br>
3: Boot ROM configures peripherals and loads/expands Nintendo logo from cartridge to VRAM<br>
4: Boot ROM continues w/o accessing cartridge (scrolling logo down)<br>
5: Approximated reset ramp (I don't have a relation between this logic diagram and the oscilloscope screen
below, so take this with a grain of salt)</i></p>
<p><img src="img/reset_rise.png" alt=""><br>
<i><u>Picture 2</u><br>
Rising #reset line</i></p>
<h2>Boot ROM external bus access</h2>
<p>The boot ROM runs for exactly 57358 clock cycles before any of the lines (except clock) is changing. For now,
I assume a clock cycle starts and ends with a rising edge, although this is probably wrong. The very first cycle
is an exception, because the #clock line is already high when the cycle starts, there is no rising edge. That is
why the measurement in <i>Picture 1</i> displays only 57357 full cycles. This is the code that gets executed
during this time:</p>
<pre>
   0:   31 fe ff        ld sp,0xfffe   ; 3 cycles
   3:   af              xor a          ; 1
   4:   21 ff 9f        ld hl,0x9fff   ; 3                           _
   7:   32              ld (hld),a     ; 2                            \
   8:   cb 7c           bit 7,h        ; 2                             \--&gt; loop: 57343 cycles
   a:   20 fb           jr nz,0x0007   ; 3 when jumping; 2 otherwise __/
   c:   21 26 ff        ld hl,0xff26   ; 3
   f:   0e 11           ld c,0x11      ; 2
  11:   3e 80           ld a,0x80      ; 2 cycles  &lt;-- ends at cycle #57357
  13:   32              ld (hld),a     ; 2         &lt;-- ends at cycle #57359, address lines reflect 0xff26
  14:   e2              ld (c),a
  15:   0c              inc c
  16:   3e f3           ld a,0xf3
  18:   e2              ld (c),a
  19:   32              ld (hld),a
  1a:   3e 77           ld a,0x77
  1c:   77              ld (hl),a
  1d:   3e fc           ld a,0xfc
  1f:   e0 47           ld (0x47),a
</pre>
<p>The VRAM access during the loop at 0x7-0xA is not visible on the external memory bus. The first thing that
can be seen on the externel bus is the operation at 0x13, which writes 0x80 into the APU register 0xff26. The
instruction fetch happens at cycle #57358, the write operation at #57359. During this operation, the address
lines reflect the actual address (0xff26). The #read signal may glitch sometimes for a few nanoseconds. In the
picture below, these glitches measure 41.67ns. When I use a sample rate of 100M/s, they go down to 20ns and
sometimes even 10ns. The data lines stay unchanged and #write stays high (deasserted). All reads and writes to
registers and HRAM (0xff??) seem to behave this way.</p>
<p><img src="img/boot_rom_wr_ff26.png" alt=""><br>
<i><u>Picture 3</u> (24M/s)<br>
Boot ROM instructions at address 0x13 and 0x14</i></p>
<p><img src="img/boot_rom-rw_overview.png" alt=""><br>
<i><u>Picture 4</u> (24M/s)<br>
1: Boot ROM execution w/o accessing cartridge ROM<br>
2: Boot ROM comparing Nintendo logo (executing at addresses 0xe0...0xf0)<br>
3: Boot ROM checking header sum (executing 0xf1...0xfb)<br>
4: Executing code in cartridge ROM (startup code of <a href="../test_roms/rom-rw.gb">rom-rw.gb</a>: <a href="../test_roms/common.s">common.s</a>)<br>
5: Executing code in HRAM (main loop of <a href="../test_roms/rom-rw.gb">rom-rw.gb</a>: <a href="../test_roms/rom-rw.s">rom-rw.s</a>)</i></p>
<h2>Memory Overview</h2>
<p>The patterns that are visible on the two external busses of the chip are depending on which components are accessed
by the CPU, PPU and DMA. The following table shows the memory map as seen by the CPU. Although in reality this is much
more spaghetti-ish, I tried to divide the various components into four busses. This grouping is only for describing which
signal patterns can be seen when a component from any of those groups is accessed. The boot ROM got its own group even
though it should be logically fit in the "Internal Bus" group, because for some reason it deviates from the patterns
seen in this group.</p>
<table class="default center">
<tr>
<th><i>mapping</i></th>
<th style="background-color:#ffe0e0;">External Bus</th>
<th style="background-color:#ffffe0;">Internal Bus</th>
<th style="background-color:#e0e0ff;">External Video Bus</th>
<th style="background-color:#e0ffff;">Internal Video Bus</th>
<th style="background-color:#e0ffe0;">Boot ROM</th>
</tr><tr>
<th>Boot ROM<br>0x0000-0x00FF</th>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X <i>(*)</i></td>
</tr><tr>
<th>Cartridge ROM<br>0x0000-0x7FFF</th>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr><tr>
<th>Video RAM<br>0x8000-0x9FFF</th>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr><tr>
<th>Cartridge RAM<br>0xA000-0xBFFF</th>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr><tr>
<th>Work RAM<br>0xC000-0xDFFF</th>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr><tr>
<th><i>unused area</i><br>0xE000-0xFDFF</th>
<td>X <i>(**)</i></td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr><tr>
<th>OAM RAM<br>0xFE00-0xFE9F</th>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
</tr><tr>
<th><i>unused area</i><br>0xFEA0-0xFEFF</th>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>?</td>
<td>&nbsp;</td>
</tr><tr>
<th>Registers<br>0xFF00-0xFF7F</th>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr><tr>
<th>Work &amp; Stack RAM<br>0xFF80-0xFFFE</th>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr><tr>
<th>IE Register<br>0xFFFF</th>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
</table>
<p><i><u>Table 1</u><br>
(*): 0x0000-0x00FF is only mapped to the boot ROM during boot;
gets cut off when boot ROM code writes 0x01 to register 0xFF50<br>
(**): 0xE000-0xFDFF is often called the WRAM echo or shadow area; actually the cartridge
RAM may also respond here, which could lead to short circuits during read operations</i></p>
<p>On the external bus, A15 serves as a low active ROM chip select. It will only switch to low when the
cartridge ROM gets accessed. It will immediatly switch back to high at the end of the read/write operation. The
other address lines (A0-A14) keep their state until another bus access is causing them to change. The #cs signal
serves as a chip select for both RAMs on the external bus (WRAM and cartridge RAM). It behaves the same way as
A15 does for the cartridge ROM. The WRAM uses A14 as a secondary, high active chip select. The cartridge RAM uses
A13 as a secondary, high active chip select. Still, A13 and A14 act like the other address lines, not like the
primary chip selects (#cs and A15). When accesing the address range 0xE000-0xFDFF, both A13 and A14 are high
and therefore both RAMs are active.</p>
<p>When #read is low, D0-D7 are always configured as inputs (driven by the cartridge or WRAM or pulled up by
a pull-up resistor). When #read is high and a chip select (#cs or A15) is low, D0-D7 are always configured as
outputs (driven by the GameBoy). There is a short switching period when #read and both chip selects are high.</p>
<table class="default center" style="background-color:#ffe0e0;">
<tr>
<th><i>&amp;&amp;</i></th>
<th>!(#cs) &amp;&amp; (A15)</th>
<th>(#cs) &amp;&amp; (A15)</th>
<th>(#cs) &amp;&amp; !(A15)</th>
</tr><tr>
<th>!(#read)</th>
<td>input &rarr;<br>&nbsp;</td>
<td>&larr; input <i>(*)</i> &rarr;<br>&darr;</td>
<td>&larr; input<br>&nbsp;</td>
</tr><tr>
<th>(#read)</th>
<td>&nbsp;<br>output &rarr;</td>
<td>&uarr;<br>&larr; undefined &rarr;</td>
<td>&nbsp;<br>&larr; output</td>
</tr>
</table>
<p><i><u>Table 2</u><br>
Arrows: Indicate legal state changes<br>
(*): The "default" state, when cartridge and WRAM are not accessed</i></p>
<p>There are two peripherals that also gain access to some of the busses: The PPU and the DMA. The PPU has
the highest priority, the CPU has the lowest.</p>
<table class="default center">
<tr>
<th><i>has access to bus<br>(ordered by priority)</i></th>
<th style="background-color:#e0ffe0;">Boot ROM</th>
<th style="background-color:#ffe0e0;">External Bus</th>
<th style="background-color:#ffffe0;">Internal Bus</th>
<th style="background-color:#e0e0ff;">External Video Bus</th>
<th style="background-color:#e0ffff;">Internal Video Bus</th>
</tr><tr>
<th>PPU</th>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X (ro)</td>
<td>X (ro)</td>
</tr><tr>
<th>DMA</th>
<td>?</td>
<td>X (ro)</td>
<td>?</td>
<td>X (ro)</td>
<td>X (wo)</td>
</tr><tr>
<th>CPU</th>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</table>
<p><i><u>Table 3</u></i></p>
<table class="default" style="background-color:#ffe0e0;">
<tr>
<th><i>signals visible on<br>external bus during<br>CPU mem access</i></th>
<th>#write</th>
<th>#read</th>
<th>#cs</th>
<th>A15</th>
<th>A0-A14</th>
<th>D0-D7 direction</th>
<th>D0-D7 output buffer</th>
</tr><tr>
<th style="background-color:#e0ffe0;">Boot ROM (*)</th>
<td>high</td>
<td>low</td>
<td>high</td>
<td>high</td>
<td>no change TODO: double check; A8 seems to go low when accessing boot ROM</td>
<td>input</td>
<td>no change</td>
</tr><tr>
<th style="background-color:#ffe0e0;">External Bus</th>
<td>w: low<br>r: high</td>
<td>w: high<br>r: low</td>
<td>high</td>
<td>low</td>
<td>change</td>
<td>w: output<br>r: input</td>
<td>w: change<br>r: no change</td>
</tr><tr>
<th style="background-color:#ffffe0;">Internal Bus</th>
<td>high</td>
<td>w: low (glitchy)<br>r: low</td>
<td>high</td>
<td>high</td>
<td><b>change</b></td>
<td>input</td>
<td>no change</td>
</tr><tr>
<th style="background-color:#e0e0ff;">External Video Bus</th>
<td>high</td>
<td>w: low (glitchy)<br>r: low</td>
<td>high</td>
<td>high</td>
<td>no change</td>
<td>input</td>
<td>no change</td>
</tr><tr>
<th style="background-color:#e0ffff;">Internal Video Bus</th>
<td>high</td>
<td>w: low (glitchy)<br>r: low</td>
<td>high</td>
<td>high</td>
<td><b>change</b></td>
<td>input</td>
<td>no change</td>
</tr>
</table>
<p><i><u>Table 4</u><br>
Signals visible on external bus when CPU accesses any of the five groups (while DMA is not accessing WRAM or cartridge)<br>
(*): Write access on boot ROM not tested yet</i></p>
<table class="default" style="background-color:#e0e0ff;">
<tr>
<th><i>signals visible on<br>ext. video bus during<br>CPU mem access</i></th>
<th>#vwrite</th>
<th>#vread</th>
<th>#vcs</th>
<th>VA0-VA12</th>
<th>VD0-VD7 direction</th>
<th>VD0-VD7 output buffer</th>
</tr><tr>
<th style="background-color:#e0ffe0;">Boot ROM (*)</th>
<td>high</td>
<td>low</td>
<td>high</td>
<td><b>change</b></td>
<td>input</td>
<td>?</td>
</tr><tr>
<th style="background-color:#ffe0e0;">External Bus</th>
<td>?</td>
<td>?</td>
<td>high</td>
<td><b>change</b></td>
<td>input</td>
<td>?</td>
</tr><tr>
<th style="background-color:#ffffe0;">Internal Bus</th>
<td>?</td>
<td>?</td>
<td>high</td>
<td><b>change</b></td>
<td>input</td>
<td>?</td>
</tr><tr>
<th style="background-color:#e0e0ff;">External Video Bus</th>
<td>w: low<br>r: high</td>
<td>w: high<br>r: low</td>
<td>low</td>
<td>change</td>
<td>w: output<br>r: input</td>
<td>w: change<br>r: ?</td>
</tr><tr>
<th style="background-color:#e0ffff;">Internal Video Bus</th>
<td>high</td>
<td>low</td>
<td>high</td>
<td><b>change</b></td>
<td>input</td>
<td>?</td>
</tr>
</table>
<p><i><u>Table 5</u><br>
Signals visible on external video bus when CPU accesses any of the five groups (while PPU and DMA are not accessing VRAM)<br>
(*): Write access on boot ROM not tested yet</i></p>
<table class="default" style="background-color:#e0e0ff;">
<tr>
<th><i>signals visible on<br>ext. video bus during<br>PPU mem access</i></th>
<th>#vwrite</th>
<th>#vread</th>
<th>#vcs</th>
<th>VA0-VA12</th>
<th>VD0-VD7 direction</th>
</tr><tr>
<th style="background-color:#e0e0ff;">External Video Bus</th>
<td>high</td>
<td>low</td>
<td>low</td>
<td>change</td>
<td>input (glitchy)</td>
</tr><tr>
<th style="background-color:#e0ffff;">Internal Video Bus</th>
<td colspan="5" style="text-align:center;">controlled by DMA or CPU</td>
</tr>
</table>
<p><i><u>Table 6</u><br>
Signals visible on external video bus when PPU accesses any of the two busses</i></p>
<table class="default" style="background-color:#ffe0e0;">
<tr>
<th><i>signals visible on<br>external bus during<br>DMA mem access</i></th>
<th>#write</th>
<th>#read</th>
<th>#cs</th>
<th>A15</th>
<th>A0-A14</th>
<th>D0-D7 direction</th>
</tr><tr>
<th style="background-color:#e0ffe0;">Boot ROM (*)</th>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr><tr>
<th style="background-color:#ffe0e0;">External Bus</th>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr><tr>
<th style="background-color:#ffffe0;">Internal Bus (*)</th>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr><tr>
<th style="background-color:#e0e0ff;">External Video Bus</th>
<td colspan="6" style="text-align:center;">controlled by CPU</td>
</tr><tr>
<th style="background-color:#e0ffff;">Internal Video Bus</th>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</table>
<p><i><u>Table 7</u><br>
Signals visible on external bus when DMA accesses any of the three/five (*) groups<br>
(*): Not tested yet if DMA has access to boot ROM or internal bus</i></p>
<table class="default" style="background-color:#e0e0ff;">
<tr>
<th><i>signals visible on<br>ext. video bus during<br>DMA mem access</i></th>
<th>#vwrite</th>
<th>#vread</th>
<th>#vcs</th>
<th>VA0-VA12</th>
<th>VD0-VD7 direction</th>
</tr><tr>
<th style="background-color:#e0ffe0;">Boot ROM (*)</th>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr><tr>
<th style="background-color:#ffe0e0;">External Bus</th>
<td colspan="5" style="text-align:center;">controlled by PPU or CPU</td>
</tr><tr>
<th style="background-color:#ffffe0;">Internal Bus (*)</th>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr><tr>
<th style="background-color:#e0e0ff;">External Video Bus</th>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr><tr>
<th style="background-color:#e0ffff;">Internal Video Bus</th>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</table>
<p><i><u>Table 8</u><br>
Signals visible on external video bus when DMA accesses any of the three/five (*) groups (while PPU is not accessing VRAM)<br>
(*): Not tested yet if DMA has access to boot ROM or internal bus</i></p>
<!--
CPU write WRAM:
  950ns clk period:
    140ns-150ns  #rd  low -> high
    150ns        a0   change            # also for read; also for HRAM and OAM; this is also the point where #rd glitches during HRAM and OAM write access
    240ns-250ns  #cs  high -> low
    470ns-480ns  clk  high -> low
    480ns-490ns  #wr  high -> low
    500ns        d0   input -> output
    830ns-840ns  #wr  low -> high
    950ns        clk  low -> high
    950ns-960ns  #cs  low -> high
    950ns-960ns  d0   output -> input
    980ns        #rd  high -> low
   1100ns-1110ns a0   change            # also for read
  960ns clk period:
    150ns        #rd  low -> high
    150ns-160ns  a0   change
    250ns        #cs  high -> low
    480ns-490ns  clk  high -> low
    490ns        #wr  high -> low
    500ns        d0   input -> output
    700ns-710ns  d0   sampling takes place here during read
    840ns        #wr  low -> high
    960ns        clk  low -> high
    960ns        #cs  low -> high
    960ns        d0   output -> input
    990ns        #rd  high -> low
   1100ns-1110ns a0   change

I removed the EverDrive cartridge for determining the timings of the data lines during writes, because
I have the suspicion, that this cartridge messes around with the data lines during writes to the ROM and
cartridge RAM. When writing to cartridge RAM, it keeps the state of the data lines as they were written when
the GameBoy stops driving the lines. It does that without noticeable peaks of the pull-ups. When writing to
ROM, the EverDrive seems to drive the data lines as soon as the chip select (A15) goes low, even when #rd is
high. It seems like it is always driving the lines with the same value they were driven before by the GameBoy.
It stops driving when #wr goes low, but remembers the written value for next time. I suspect that the
EverDrive has "keeper" pull-up/down resistors, that keep the lines at their last state. Maybe it saves power
to avoid the slow signal transitions from low to high, that normally happen without the EverDrive.

DMA read WRAM start (period #1/160):
  950ns clk period:
    10ns         #cs  high -> low
    10ns         a0   change
    480ns        clk  high -> low
    960ns        a0   change
DMA read WRAM end (period #160/160):
  950ns clk period:
    10ns         a0   change
    480ns        clk  high -> low
    960ns        #cs  low -> high
    1100ns       a0   change
DMA keeps #cs low for all 160 cycles. No glitches.

DMA read VRAM start (period #1/160):
  950ns clk period:
    10ns         #vcs high -> low
    10ns         va0  change
    480ns        clk  high -> low
    950ns        clk  low -> high
    960ns        va0  change
DMA read VRAM end (period #160/160):
  950ns clk period:
    10ns         va0  change
    480ns        clk  high -> low
    950ns        clk  low -> high
    960ns        #vcs low -> high
    1100ns       va0  change
DMA keeps #vcs low for all 160 cycles, even when PPU takes over! No glitches.

CPU write VRAM:
  950ns clk period:
    140ns        #vrd low -> high
    30ns         va0  -> low        # address lines always go low first when CPU accesses VRAM
    140ns        va0  change
    240ns        #vcs high -> low
    480ns        clk  high -> low
    480ns        #vwr high -> low
    500ns        vd0  input -> output
    830ns        #vwr low -> high
    950ns        clk  low -> high
    960ns        #vcs low -> high
    960ns        vd0  output -> input
    980ns        #vrd high -> low

If PPU is not accessing VRAM, #vrd stays low when idle just like #rd on the external bus. When the PPU
reads from VRAM, #vrd periodically goes high.
-->
<!--
What happens when DMA reads 0xff00? Does it access the 0xe000 (echo) region?
-->
</body>
</html>
